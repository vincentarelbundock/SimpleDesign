#' Diagnose a statistical model and data generating process
#'
#' #' Diagnose a Statistical Model and Data Generating Process
#'
#' This function evaluates the performance of a statistical model (or estimator)
#' against data generated from a specified data generating process (DGP). It computes
#' various diagnostic metrics, including root mean squared error (RMSE), bias, power,
#' and confidence interval coverage.
#'
#' @param dgp A function that generates a dataset. This function should return
#'   a data frame when called, and optionally accept parameters passed via
#'   `dgp_parameters`.
#' @param fit A function that fits the model to the data generated by `dgp`.
#'   This function should return a data frame with columns including
#'   `estimator`, `term`, `estimate`, and optionally `p.value`, `conf.low`,
#'   and `conf.high`.
#' @param truth A numeric value representing the true value of the parameter
#'   being estimated. This is used to compute bias, RMSE, and coverage.
#' @param alpha A numeric value between 0 and 1 indicating the significance
#'   level for hypothesis tests (default is 0.05).
#' @param N An integer specifying the number of repetitions of the simulation
#'   to perform (default is 100).
#' @param dgp_parameters An optional data frame specifying parameter values
#'   to be passed to the `dgp` function. Each row corresponds to a parameter
#'   configuration for a single DGP run. If `NULL`, the `dgp` function is
#'   called without additional parameters.
#'
#' @return A data frame summarizing the diagnostic metrics:
#'   \describe{
#'     \item{rmse}{Root mean squared error of the estimates.}
#'     \item{bias}{Mean bias of the estimates.}
#'     \item{power}{Proportion of times the null hypothesis is rejected
#'       (if `p.value` column exists).}
#'     \item{coverage}{Proportion of times the confidence interval covers the
#'       true value (if `conf.low` and `conf.high` columns exist).}
#'   }
#'   Each row corresponds to a combination of `estimator`, `term`, and other
#'   grouping variables.
#'
#' @details
#' The function assumes that the `fit` function returns a data frame containing
#' at least the following columns:
#' - `estimator`: Identifier for the model or method.
#' - `term`: The name of the parameter being estimated.
#' - `estimate`: The estimated value of the parameter.
#'
#' Additional columns such as `p.value`, `conf.low`, and `conf.high` are used
#' for computing power and coverage metrics if they are present.
#'
#' The `dgp_parameters` argument allows for systematic variation of the DGP's
#' inputs across simulations. For each parameter configuration (a row in
#' `dgp_parameters`), the DGP is called, and the resulting data is passed to
#' the `fit` function.
#'
#'
#' @import data.table
#' @export
diagnose = function(dgp,
                    fit,
                    alpha = 0.05,
                    N = 100,
                    dgp_parameters = NULL) {
  checkmate::assert_integerish(N, lower = 1, len = 1)
  checkmate::assert_number(alpha, lower = 0, upper = 1)
  checkmate::assert_data_frame(dgp_parameters, null.ok = TRUE)

  fit_cols = c("estimator", "term", "estimate", "p.value", "conf.low", "conf.high")

  out = list()

  for (i in seq_len(N)) {
    if (is.null(dgp_parameters)) {
      d = dgp()
      assert_dgp(d)
      f = fit(d)
      assert_fit(f)
      f[["truth"]] = sanitize_truth(d, f)
      out = c(out, list(f))
    } else {
      for (k in seq_len(nrow(dgp_parameters))) {
        d = do.call(dgp, as.list(dgp_parameters[k, ]))
        assert_dgp(d)
        f = fit(d)
        assert_fit(f)
        f[["truth"]] = sanitize_truth(d, f)
        f = merge(f, dgp_parameters[k, , drop = FALSE])
        out = c(out, list(f))
      }
    }
  }

  results = data.table::rbindlist(out)

  by_cols = c("estimator", "term", setdiff(colnames(results), fit_cols))
  by_cols = intersect(by_cols, colnames(results))
  if (length(by_cols) == 0) by_cols = NULL

  out = list()

  out[["bias"]] = results[, list(bias = mean(estimate - truth)), by = by_cols]
  out[["rmse"]] = results[, list(rmse = sqrt(mean((estimate - truth)^2))), by = by_cols]

  if ("p.value" %in% colnames(results)) {
    results[, power := p.value < alpha]
    out[["power"]] = results[, list(power = mean(power)), by = by_cols]
  }

  if (all(c("conf.low", "conf.high") %in% colnames(results))) {
    results[, coverage := conf.low <= truth & conf.high >= truth]
    out[["coverage"]] = results[, list(coverage = mean(coverage)), by_cols]
  }

  out = Filter(function(x) !is.null(x), out)
  out = Reduce(function(x, y) merge(x, y, by = by_cols), out)

  data.table::setDF(out)
  row.names(out) = NULL

  class(out) = c("SimpleDiagnostic", "data.frame")

  return(out)
}


assert_fit = function(f) {
  checkmate::assert_data_frame(f, .var.name = "fit(data)")
  fit_cols = c("estimator", "term", "estimate", "p.value", "conf.low", "conf.high")
  if (any(!colnames(f) %in% fit_cols)) {
    msg = "fit() can only include these column names: %s"
    msg = sprintf(msg, paste(fit_cols, collapse = ", "))
    stop(msg, call. = FALSE)
  }
  if (!isTRUE("estimate" %in% colnames(f)) || !is.numeric(f$estimate)) {
    msg = "fit() must return a data frame with an 'estimate' column with numeric values."
    stop(msg, call. = FALSE)
  }
  if (!isTRUE("estimator" %in% colnames(f))) {
    msg = "fit() must return a data frame with an 'estimator' column with the estimator label as string."
    stop(msg, call. = FALSE)
  }
  if ("truth" %in% colnames(f)) {
    msg = "fit() cannot include a 'truth' column."
    stop(msg, call. = FALSE)
  }
}


assert_dgp = function(d) {
  checkmate::assert_data_frame(d, .var.name = "dgp()")
  truth = attr(d, "truth")
  if (!isTRUE(checkmate::check_numeric(truth))) {
    msg = "dgp() must return a data frame with a 'truth' attribute containing the true value of the parameter being estimated. See the examples in the documentation: `?diagnose`"
    stop(msg, call. = FALSE)
  }
  if ("truth" %in% colnames(d)) {
    msg = "dgp() cannot include a 'truth' column."
    stop(msg, call. = FALSE)
  }
}


sanitize_truth = function(d, f) {
  truth = attr(d, "truth")
  if (length(truth) != 1 && length(truth) != nrow(f)) {
    msg = sprintf("The 'truth' attribute in the DGP must be a single value or a vector of length equal to the number of rows in the fit() output. Found %d values, expected %s", length(truth), paste(unique(c(1, nrow(f)), collapse = " or ")))
    stop(msg, call. = FALSE)
  }
  return(truth)
}
