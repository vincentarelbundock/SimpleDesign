[{"path":"https://vincentarelbundock.github.io/simpledesign/articles/tutorial.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"SimpleDesign tutorial","text":"","code":"remotes::install_github(\"vincentarelbundock/SimpleDesign\")"},{"path":"https://vincentarelbundock.github.io/simpledesign/articles/tutorial.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"SimpleDesign tutorial","text":"SimpleDesign workflow starts defining two simple functions: Input: Parameters control data generating process (DGP) Output: Data model fitting function true value estimand Input: Data frame generated dgp() Mandatory: estimator estimate Optional: conf.low, conf.high, p.value, etc. SimpleDesign workflow ends calling diagnose() function: rest vignette shows concrete examples, simple complex.","code":"diagnose(dgp, fit)"},{"path":"https://vincentarelbundock.github.io/simpledesign/articles/tutorial.html","id":"simple-data-generating-process","dir":"Articles","previous_headings":"","what":"Simple data generating process","title":"SimpleDesign tutorial","text":"First, load package define dgp() function encodes simple data generating process (DGP): two-arm randomized controlled trial N=100N=100 observations, outcome YY, random treatment TT, treatment effect θ=0.5\\theta=0.5. dgp() function must return data frame called. data frame must also “truth” attribute, holds true value estimand targetting. Next, define fit() function. function accepts data frame, fits model, returns data frame estimates. data frame must absolutely include estimate column numeric values. Finally, feed dgp() fit() functions diagnose() function. function simulate data dgp() function, fit models using fit() function, return data frame diagnostic statistics. truth attribute generated data specifies true value quantity interest, benchmark estimates. fit() function can also produce data frames additional columns like conf.low, conf.high, p.values. columns present, diagnose() generate useful diagnostic statistics. Extracting information models relatively easy, inconvenient. make process easier, SimpleDesign supplies extract_estimates() function. mandatory label argument adds new column unique label. optional term argument specifies subset parameters extract model. Since fit() output now includes pp value confidence interval, diagnose() now reports useful statistics.","code":"library(SimpleDesign)  dgp = function(theta = 0.5, N = 50) {   T = rbinom(N, 1, .5) # treatment   e = rnorm(N) # noise   Y = theta * T + e # outcome    # output data frame   data = data.frame(Y, T)    # set the \"truth\" attribute   attr(data, \"truth\") = theta   return(data) }  dgp() |> head() Y T 1 -0.37302813 0 2 -1.14314590 1 3  0.63552187 0 4 -1.15922120 1 5 -0.34179292 1 6 -0.04156007 0 fit = function(data) {   model = lm(Y ~ T, data = data)   results = data.frame(     estimator = \"OLS\",     estimate = coef(model)[\"T\"]   )   return(results) }  dgp() |> fit() estimator  estimate T       OLS 0.5859094 diagnose(dgp, fit) estimator truth       bias      rmse 1       OLS   0.5 0.01775981 0.2569797 fit = function(data) {   model = lm(Y ~ T, data = data)   results = extract_estimates(OLS = model, term = \"T\")   return(results) }  dgp() |> fit() estimator term  estimate   p.value   conf.low conf.high 1       OLS    T 0.5012431 0.1422529 -0.1682288  1.170715 diagnose(dgp, fit) estimator term truth         bias      rmse power coverage 1       OLS    T   0.5 -0.001086504 0.2776061  0.37     0.92"},{"path":"https://vincentarelbundock.github.io/simpledesign/articles/tutorial.html","id":"dgp-parameters","dir":"Articles","previous_headings":"","what":"DGP parameters","title":"SimpleDesign tutorial","text":"dgp() function two arguments control sample effect sizes. can diagnose several research designs one go supplying data frame DGP parameters dgp_parameters argument diagnose(). example, use expand.grid() function base R build data frame combinations parameter values.","code":"param = expand.grid(N = c(100, 500), theta = c(0.1, 0.5, 1)) param N theta 1 100   0.1 2 500   0.1 3 100   0.5 4 500   0.5 5 100   1.0 6 500   1.0 diagnose(dgp, fit, N = 100, dgp_parameters = param) estimator term truth   N theta         bias       rmse power coverage 1       OLS    T   0.1 100   0.1 -0.000039723 0.17967811  0.07     0.99 2       OLS    T   0.1 500   0.1  0.007538356 0.09246109  0.23     0.92 3       OLS    T   0.5 100   0.5  0.052107175 0.20274188  0.84     0.94 4       OLS    T   0.5 500   0.5  0.005333471 0.08670184  1.00     0.96 5       OLS    T   1.0 100   1.0  0.010563482 0.21025858  1.00     0.95 6       OLS    T   1.0 500   1.0  0.003589011 0.08514632  1.00     0.96"},{"path":"https://vincentarelbundock.github.io/simpledesign/articles/tutorial.html","id":"complex-data-generating-process","dir":"Articles","previous_headings":"","what":"Complex data generating process","title":"SimpleDesign tutorial","text":"Since dgp() just standard R function, users free define complex data generating processes using whatever helper functions wish. example, fabricatr randomizr packages offer extremely powerful functions generate simulated data special random assignment schemes. example, dgp() generates data block random assignment design. Now, define fit function see “naive” linear regression model retrieves good estimate estimand. Finally, diagnose research design.","code":"dgp = function(n_blocks = 3, n_indiv = 100, e_sd = 1) {   data = fabricatr::fabricate(     # block-level variables     block = fabricatr::add_level(       N = n_blocks,        # individual treatment effect       tau = c(4, 2, 0)     ),      # individual-level variables     indiv = fabricatr::add_level(       N = n_indiv,        # noise       e = rnorm(N, sd = e_sd),        # potential outcomes       Y_T_0 = e,       Y_T_1 = e + tau     )   )   data$T = randomizr::block_ra(blocks = data$block, block_prob = c(.5, .7, .9))   data$Y = ifelse(data$T == 1, data$Y_T_1, data$Y_T_0)    # define truth in terms of potential outcomes   attr(data, \"truth\") = mean(data$Y_T_1 - data$Y_T_0)    return(data) }  dgp() |> head() block tau indiv          e      Y_T_0    Y_T_1 T          Y 1     1   4   001  1.0472749  1.0472749 5.047275 1  5.0472749 2     1   4   002 -0.4902355 -0.4902355 3.509765 0 -0.4902355 3     1   4   003  2.1545182  2.1545182 6.154518 0  2.1545182 4     1   4   004  0.9860548  0.9860548 4.986055 0  0.9860548 5     1   4   005  1.4483193  1.4483193 5.448319 0  1.4483193 6     1   4   006  0.7895540  0.7895540 4.789554 1  4.7895540 dgp() |> attr(\"truth\") [1] 2 fit = function(data) {   model = lm(Y ~ T, data = data)   results = extract_estimates(OLS = model, term = \"T\")   return(results) } diagnose(dgp, fit) estimator term truth      bias      rmse power coverage 1       OLS    T     2 -0.386235 0.4063862     1     0.62"},{"path":"https://vincentarelbundock.github.io/simpledesign/articles/tutorial.html","id":"comparing-estimators","dir":"Articles","previous_headings":"","what":"Comparing estimators","title":"SimpleDesign tutorial","text":"Perhaps switch estimators. described DeclareDesign blog, try control blocks fixed effects linear model, estimate differences--means group average . last option implemented differences_in_means() function estimatr package. , use extract_estimates() helper function, accepts named list models, returns simple data frame appropriate labels. illustrate, let’s simulate single dataset, store three fitted models named list, call extract_estimates(). fun, also set α\\alpha level used build confidence intervals 0.01. Using helper function, can define new fit() compare different modelling strategies: results show difference--means strategy yields unbiased results adequate coverage. extend investigation consider different DGP parameters:","code":"data = dgp()  extract_estimates(   `Naive LM` = lm(Y ~ T, data = data),   `Block controls` = lm(Y ~ T + block, data = data),   `DinM` = estimatr::difference_in_means(Y ~ T, blocks = block, data = data),   term = \"T\",   alpha = 0.01 ) estimator term estimate      p.value conf.low conf.high 1       Naive LM    T 1.688476 2.062754e-16 1.159268  2.217683 2 Block controls    T 2.628537 1.708860e-63 2.226028  3.031047 3           DinM    T 2.071378 9.103336e-57 1.735331  2.407425 fit = function(data) {   model = lm(Y ~ T, data = data)   results = extract_estimates(     `Naive LM` = lm(Y ~ T, data = data),     `Block controls` = lm(Y ~ T + block, data = data),     `DinM` = estimatr::difference_in_means(Y ~ T, blocks = block, data = data),     term = \"T\",     alpha = 0.01   )   return(results) } diagnose(dgp, fit) estimator term truth         bias      rmse power coverage 1 Block controls    T     2  0.579808242 0.5948968     1     0.10 2           DinM    T     2 -0.006437012 0.1472254     1     0.99 3       Naive LM    T     2 -0.383467860 0.4036736     1     0.88 param = expand.grid(n_indiv = c(100, 500), e_sd = c(1, 2))  diagnose(dgp, fit, dgp_parameters = param) estimator term truth n_indiv e_sd          bias       rmse power coverage 1  Block controls    T     2     100    1  0.5900080579 0.60494390     1     0.07 2  Block controls    T     2     100    2  0.5514600278 0.60759485     1     0.78 3  Block controls    T     2     500    1  0.5740810393 0.57671783     1     0.00 4  Block controls    T     2     500    2  0.5848918067 0.59858053     1     0.00 5            DinM    T     2     100    1  0.0009265808 0.13423367     1     1.00 6            DinM    T     2     100    2 -0.0136474020 0.31326195     1     0.98 7            DinM    T     2     500    1 -0.0140148171 0.06272271     1     1.00 8            DinM    T     2     500    2 -0.0028456426 0.13729211     1     0.99 9        Naive LM    T     2     100    1 -0.3788130041 0.39582041     1     0.94 10       Naive LM    T     2     100    2 -0.4028174998 0.46559315     1     0.94 11       Naive LM    T     2     500    1 -0.3872243800 0.39076056     1     0.01 12       Naive LM    T     2     500    2 -0.3759156865 0.39481790     1     0.39"},{"path":"https://vincentarelbundock.github.io/simpledesign/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Vincent Arel-Bundock. Author, maintainer.","code":""},{"path":"https://vincentarelbundock.github.io/simpledesign/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Arel-Bundock V (2024). SimpleDesign: DeclareDesign Dummies Like . R package version 0.0.1, https://vincentarelbundock.github.io/simpledesign.","code":"@Manual{,   title = {SimpleDesign: DeclareDesign for Dummies Like Me},   author = {Vincent Arel-Bundock},   year = {2024},   note = {R package version 0.0.1},   url = {https://vincentarelbundock.github.io/simpledesign}, }"},{"path":"https://vincentarelbundock.github.io/simpledesign/index.html","id":"simpledesign","dir":"","previous_headings":"","what":"DeclareDesign for Dummies Like Me","title":"DeclareDesign for Dummies Like Me","text":"simple package simulate diagnose research designs: Simulate Fit Bias RMSE Power Coverage strongly influenced amazing DeclareDesign package. Warning: just quick Saturday morning project see roll simple solution. Nobody use serious work.","code":""},{"path":"https://vincentarelbundock.github.io/simpledesign/index.html","id":"simple-data-generating-process","dir":"","previous_headings":"","what":"Simple data generating process","title":"DeclareDesign for Dummies Like Me","text":"First, load package define dgp() function encodes simple data generating process (DGP): two-arm randomized controlled trial N = 100 observations, outcome Y, random treatment T, treatment effect θ = 0.5. dgp() function must return data frame called. data frame must also “truth” attribute, holds true value estimand targetting. Next, define fit() function. function accepts data frame, fits model, returns data frame estimates. data frame must absolutely include estimate column numeric values. Finally, feed dgp() fit() functions diagnose() function. function simulate data dgp() function, fit models using fit() function, return data frame diagnostic statistics. truth attribute generated data specifies true value quantity interest, benchmark estimates. fit() function can also produce data frames additional columns like conf.low, conf.high, p.values. columns present, diagnose() generate useful diagnostic statistics. Extracting information models relatively easy, inconvenient. make process easier, SimpleDesign supplies tidy_estimator() function. mandatory label argument adds new column unique label. optional term argument specifies subset parameters extract model. Since fit() output now includes p value confidence interval, diagnose() now reports useful statistics.","code":"library(SimpleDesign)  dgp = function(theta = 0.5, N = 50) {   T = rbinom(N, 1, .5) # treatment   e = rnorm(N) # noise   Y = theta * T + e # outcome    # output data frame   data = data.frame(Y, T)    # set the \"truth\" attribute   attr(data, \"truth\") = theta   return(data) }  dgp() |> head() Y T 1 -0.37302813 0 2 -1.14314590 1 3  0.63552187 0 4 -1.15922120 1 5 -0.34179292 1 6 -0.04156007 0 fit = function(data) {   model = lm(Y ~ T, data = data)   results = data.frame(     estimator = \"OLS\",     estimate = coef(model)[\"T\"]   )   return(results) }  dgp() |> fit() estimator  estimate T       OLS 0.5859094 diagnose(dgp, fit) estimator truth       bias      rmse 1       OLS   0.5 0.01775981 0.2569797 fit = function(data) {   model = lm(Y ~ T, data = data)   results = tidy_estimator(model, label = \"OLS\", term = \"T\")   return(results) }  dgp() |> fit() estimator term  estimate   p.value   conf.low conf.high 2       OLS    T 0.5012431 0.1422529 -0.1682288  1.170715 diagnose(dgp, fit) estimator term truth         bias      rmse power coverage 1       OLS    T   0.5 -0.001086504 0.2776061  0.37     0.92"},{"path":"https://vincentarelbundock.github.io/simpledesign/index.html","id":"dgp-parameters","dir":"","previous_headings":"","what":"DGP parameters","title":"DeclareDesign for Dummies Like Me","text":"dgp() function two arguments control sample effect sizes. can diagnose several research designs one go supplying data frame DGP parameters dgp_parameters argument diagnose(). example, use expand.grid() function base R build data frame combinations parameter values.","code":"param = expand.grid(N = c(100, 500), theta = c(0.1, 0.5, 1)) param N theta 1 100   0.1 2 500   0.1 3 100   0.5 4 500   0.5 5 100   1.0 6 500   1.0 diagnose(dgp, fit, N = 100, dgp_parameters = param) estimator term truth   N theta         bias       rmse power coverage 1       OLS    T   0.1 100   0.1 -0.000039723 0.17967811  0.07     0.99 2       OLS    T   0.1 500   0.1  0.007538356 0.09246109  0.23     0.92 3       OLS    T   0.5 100   0.5  0.052107175 0.20274188  0.84     0.94 4       OLS    T   0.5 500   0.5  0.005333471 0.08670184  1.00     0.96 5       OLS    T   1.0 100   1.0  0.010563482 0.21025858  1.00     0.95 6       OLS    T   1.0 500   1.0  0.003589011 0.08514632  1.00     0.96"},{"path":"https://vincentarelbundock.github.io/simpledesign/index.html","id":"complex-data-generating-process","dir":"","previous_headings":"","what":"Complex data generating process","title":"DeclareDesign for Dummies Like Me","text":"Since dgp() just standard R function, users free define complex data generating processes using whatever helper functions wish. example, fabricatr randomizr packages offer extremely powerful functions generate simulated data special random assignment schemes. example, dgp() generates data block random assignment design. Now, define fit function see “naive” linear regression model retrieves good estimate estimand. Finally, diagnose research design.","code":"dgp = function(n_blocks = 3, n_indiv = 100, e_sd = 1) {   data = fabricatr::fabricate(     # block-level variables     block = fabricatr::add_level(       N = n_blocks,        # individual treatment effect       tau = c(4, 2, 0)     ),      # individual-level variables     indiv = fabricatr::add_level(       N = n_indiv,        # noise       e = rnorm(N, sd = e_sd),        # potential outcomes       Y_T_0 = e,       Y_T_1 = e + tau     )   )   data$T = randomizr::block_ra(blocks = data$block, block_prob = c(.5, .7, .9))   data$Y = ifelse(data$T == 1, data$Y_T_1, data$Y_T_0)    # define truth in terms of potential outcomes   attr(data, \"truth\") = mean(data$Y_T_1 - data$Y_T_0)    return(data) }  dgp() |> head() block tau indiv          e      Y_T_0    Y_T_1 T          Y 1     1   4   001  1.0472749  1.0472749 5.047275 1  5.0472749 2     1   4   002 -0.4902355 -0.4902355 3.509765 0 -0.4902355 3     1   4   003  2.1545182  2.1545182 6.154518 0  2.1545182 4     1   4   004  0.9860548  0.9860548 4.986055 0  0.9860548 5     1   4   005  1.4483193  1.4483193 5.448319 0  1.4483193 6     1   4   006  0.7895540  0.7895540 4.789554 1  4.7895540 dgp() |> attr(\"truth\") [1] 2 fit = function(data) {   model = lm(Y ~ T, data = data)   results = tidy_estimator(model, label = \"Naive LM\", term = \"T\")   return(results) } diagnose(dgp, fit) estimator term truth      bias      rmse power coverage 1  Naive LM    T     2 -0.386235 0.4063862     1     0.62"},{"path":"https://vincentarelbundock.github.io/simpledesign/index.html","id":"robust-standard-errors","dir":"","previous_headings":"","what":"Robust standard errors","title":"DeclareDesign for Dummies Like Me","text":"confidence interval coverage seems bad. used classical standard errors used robust standard errors? check possibility, define new fit() function different vcov argument tidy_estimator(). Nope, coverage still awful.","code":"fit = function(data) {   model = lm(Y ~ T, data = data)   results = tidy_estimator(model, label = \"Naive LM\", term = \"T\", vcov = \"HC3\")   return(results) } diagnose(dgp, fit) estimator term truth       bias      rmse power coverage 1  Naive LM    T     2 -0.3949174 0.4138856     1      0.3"},{"path":"https://vincentarelbundock.github.io/simpledesign/index.html","id":"comparing-estimators","dir":"","previous_headings":"","what":"Comparing estimators","title":"DeclareDesign for Dummies Like Me","text":"Perhaps switch estimators. described DeclareDesign blog, try control blocks fixed effects linear model, estimate differences--means group average . last option implemented differences_in_means() function estimatr package. Instead using tidy_estimator() helper function, use tidy_estimator_list(). function accepts named list models, returns simple data frame appropriate labels. illustrate, let’s simulate single dataset, store three fitted models named list, call tidy_estimator_list(). fun, also set α level used build confidence intervals 0.01. Using helper function, can define new fit() compare different modelling strategies: results show difference--means strategy yields unbiased results adequate coverage. extend investigation consider different DGP parameters:","code":"data = dgp() results = list(   \"Naive LM\" = lm(Y ~ T, data = data),   \"Block controls\" = lm(Y ~ T + block, data = data),   \"DinM\" = estimatr::difference_in_means(Y ~ T, blocks = block, data = data) ) tidy_estimator_list(results, term = \"T\", alpha = 0.01) estimator term estimate      p.value conf.low conf.high 1       Naive LM    T 1.545227 8.525041e-14 1.011822  2.078631 2 Block controls    T 2.483890 1.048603e-55 2.076971  2.890809 3           DinM    T 1.939833 4.032607e-38 1.552748  2.326919 fit = function(data) {   model = lm(Y ~ T, data = data)   results = list(     \"Naive LM\" = lm(Y ~ T, data = data),     \"Block controls\" = lm(Y ~ T + block, data = data),     \"DinM\" = estimatr::difference_in_means(Y ~ T, blocks = block, data = data)   )   results = tidy_estimator_list(results, term = \"T\", alpha = 0.01)   return(results) } diagnose(dgp, fit) estimator term truth        bias      rmse power coverage 1 Block controls    T     2  0.57373725 0.5867522     1     0.12 2           DinM    T     2 -0.00969105 0.1348343     1     1.00 3       Naive LM    T     2 -0.39144633 0.4080077     1     0.90 param = expand.grid(n_indiv = c(100, 500), e_sd = c(1, 2))  diagnose(dgp, fit, dgp_parameters = param) estimator term truth n_indiv e_sd         bias       rmse power 1  Block controls    T     2     100    1  0.610320541 0.62668619     1 2  Block controls    T     2     100    2  0.622662622 0.67814423     1 3  Block controls    T     2     500    1  0.573770754 0.57712867     1 4  Block controls    T     2     500    2  0.605580676 0.61889228     1 5            DinM    T     2     100    1  0.022966149 0.15867185     1 6            DinM    T     2     100    2  0.037620062 0.29034670     1 7            DinM    T     2     500    1 -0.005377531 0.07153573     1 8            DinM    T     2     500    2  0.021910332 0.14036368     1 9        Naive LM    T     2     100    1 -0.363424865 0.38553073     1 10       Naive LM    T     2     100    2 -0.348514140 0.43758231     1 11       Naive LM    T     2     500    1 -0.389353547 0.39355522     1 12       Naive LM    T     2     500    2 -0.367407353 0.38722720     1    coverage 1      0.07 2      0.65 3      0.00 4      0.02 5      0.99 6      0.98 7      0.98 8      0.97 9      0.95 10     0.95 11     0.00 12     0.48"},{"path":"https://vincentarelbundock.github.io/simpledesign/reference/diagnose.html","id":null,"dir":"Reference","previous_headings":"","what":"Diagnose a statistical model and data generating process — diagnose","title":"Diagnose a statistical model and data generating process — diagnose","text":"#' Diagnose Statistical Model Data Generating Process","code":""},{"path":"https://vincentarelbundock.github.io/simpledesign/reference/diagnose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diagnose a statistical model and data generating process — diagnose","text":"","code":"diagnose(dgp, fit, alpha = 0.05, N = 100, dgp_parameters = NULL)"},{"path":"https://vincentarelbundock.github.io/simpledesign/reference/diagnose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diagnose a statistical model and data generating process — diagnose","text":"dgp function generates dataset. function return data frame called, optionally accept parameters passed via `dgp_parameters`. fit function fits model data generated `dgp`. function return data frame columns including `estimator`, `term`, `estimate`, optionally `p.value`, `conf.low`, `conf.high`. alpha numeric value 0 1 indicating significance level hypothesis tests (default 0.05). N integer specifying number repetitions simulation perform (default 100). dgp_parameters optional data frame specifying parameter values passed `dgp` function. row corresponds parameter configuration single DGP run. `NULL`, `dgp` function called without additional parameters. truth numeric value representing true value parameter estimated. used compute bias, RMSE, coverage.","code":""},{"path":"https://vincentarelbundock.github.io/simpledesign/reference/diagnose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diagnose a statistical model and data generating process — diagnose","text":"data frame summarizing diagnostic metrics: rmse Root mean squared error estimates. bias Mean bias estimates. power Proportion times null hypothesis rejected       (`p.value` column exists). coverage Proportion times confidence interval covers       true value (`conf.low` `conf.high` columns exist). row corresponds combination `estimator`, `term`,   grouping variables.","code":""},{"path":"https://vincentarelbundock.github.io/simpledesign/reference/diagnose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Diagnose a statistical model and data generating process — diagnose","text":"function evaluates performance statistical model (estimator) data generated specified data generating process (DGP). computes various diagnostic metrics, including root mean squared error (RMSE), bias, power, confidence interval coverage. function assumes `fit` function returns data frame containing least following columns: - `estimator`: Identifier model method. - `term`: name parameter estimated. - `estimate`: estimated value parameter. Additional columns `p.value`, `conf.low`, `conf.high` used computing power coverage metrics present. `dgp_parameters` argument allows systematic variation DGP's inputs across simulations. parameter configuration (row `dgp_parameters`), DGP called, resulting data passed `fit` function.","code":""},{"path":"https://vincentarelbundock.github.io/simpledesign/reference/extract_estimates.html","id":null,"dir":"Reference","previous_headings":"","what":"Tidy Results from a List of Estimators — extract_estimates","title":"Tidy Results from a List of Estimators — extract_estimates","text":"function applies extracts \"tidy\" output fitted model, named list fitted models. information extracted using `hyotheses()` function `marginaleffects` package.","code":""},{"path":"https://vincentarelbundock.github.io/simpledesign/reference/extract_estimates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tidy Results from a List of Estimators — extract_estimates","text":"","code":"extract_estimates(..., vcov = NULL, alpha = 0.05, null = 0, term = NULL)"},{"path":"https://vincentarelbundock.github.io/simpledesign/reference/extract_estimates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tidy Results from a List of Estimators — extract_estimates","text":"... named list fitted model objects. model passed `marginaleffects::hypotheses()`. vcov optional variance-covariance matrix function compute . Passed `extract_estimates`. alpha numeric value 0 1 specifying significance level confidence intervals (default 0.05). null numeric value representing null hypothesis parameter estimates (default 0). term optional character vector terms filter output. specified, rows matching terms returned.","code":""},{"path":"https://vincentarelbundock.github.io/simpledesign/reference/extract_estimates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tidy Results from a List of Estimators — extract_estimates","text":"data frame combining tidied results models list.   Columns include: estimator label estimator (corresponding list names). term name parameter (e.g., model term). estimate estimated value parameter. p.value p-value hypothesis test parameter. conf.low lower bound confidence interval. conf.high upper bound confidence interval.","code":""},{"path":"https://vincentarelbundock.github.io/simpledesign/reference/extract_estimates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tidy Results from a List of Estimators — extract_estimates","text":"","code":"library(SimpleDesign) extract_estimates(   `I` = lm(mpg ~ wt, data = mtcars),   `II` = lm(mpg ~ wt + disp, data = mtcars),   alpha = 0.01,   term = \"wt\" ) #>   estimator term  estimate      p.value  conf.low  conf.high #> 1         I   wt -5.344472 1.188493e-21 -6.784620 -3.9043227 #> 2        II   wt -3.350825 3.996990e-03 -6.349421 -0.3522301"}]
